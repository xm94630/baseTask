/*******************************
* 第十七章 异步
********************************/

var bee = (function(bee){


    /**************************************************************
    * 第1节  
    ***************************************************************/

    /* 
     * 研究案例1: 异步函数 【BOSS】
     *
     * 首先，一定要搞清楚5个的基础概念：
     * 1）异步函数，即能产生异步行为的函数本身。本案例中，setTimeout就是异步函数
     * 2）回调函数，作为参数传给“异步函数”的函数（或者赋值给“document.onready”的函数）。本例中，myCallback就是回调函数。
     * 3）事件处理器，已经在“事件队列”中的“回调函数”
     * 4）事件，促发“事件处理器”被调用的那个因素，比如：延时结束事件、dom加载完毕事件等等。
     * 5）列队，即事件列队。由一堆“事件处理器”组成。（有些是已经有顺序的，比如延时的，有的是暂时没有顺序，比如点击事件处理器们）
     * 5）事件循环，用于描述描述“列队”的工作方式，非常类似循环的结构。
     *
     * 其次，要明白 js（异步）事件模型。说白了，就是js事件是如何工作的，工作原理如下：
     * 每当使用异步函数的时候，其回调函数就成为事件列队中一员，即事件处理器。当某的事件触发的时候，对应的事件处理器就会被调用。
     * 它具有如下特点：
     * 1）延时性：事件处理器一定是将来运行的，哪怕是0毫秒之后！
     * 2）对应性：使用异步函数，就有其对应的“事件处理器”加入列队。
     * 3）阻塞性：“事件处理器”只有在当前运行代码结束之后才能进行，否则，处于阻塞状态。
     *
     * 最后，解决一个困扰我多年的问题：
     * js中同时提及异步和阻塞，异步的怎么会被阻塞，而阻塞的又如何还能称得上异步，到底哪里出问题了？？
     * 解答，正确的答案是，异步的js，即阻塞又不阻塞。为何怎么说呢的？我们来看一个场景：
     * 我使用了一个异步函数setTimeout，这是个异步的行为，“不会阻塞”异步之后的其他代码的执行。这个时候，setTimeout的回调函数进入队列。
     * 等待“延时结束”事件的到来。假如，延时事件来的特别快（0毫秒之后就被触发），这个回调原本就会被马上执行，但是我们说了，js是一个单线程的，
     * 你要执行你这回调函数的时候，怎么着也得保证目前的线程上是空闲的，如果这个时候还有代码在跑的话，那么就会“被阻塞”。
     * 再举一个例子，node中的下面用法：
     * fs.readFile('/etc/passwd', (err, data) => {});
     * 这个是异步的，读取文件的事情其实交给别人去做了，所以，“不会阻塞”自己的代码。读取完毕文件之后，总会有执行回调的那个时候，这个时候，如果js
     * 自身线程中的代码都没有执行完毕，该回调就会被“阻塞”。
     * 由此可见，js中的“阻塞“仅仅发生在，回调被触发的时候!! 这样子的阻塞的发生的机会其实是很低的。因为大多数的时候，js线程还是处于空闲的状态呢~
     * node服务器就得益于这样子的“事件驱动”的优势。
     *
     * 其实在html中，是可以使用多线程的，只是这些线程还是辅助于js的主线程，为什么这么说呢，在html5中的其他线程其实是有很多的限制的，比如说
     * 他不能操作DOM，否则就很容易乱套的。
     * 
     */
    bee.caseQ1 = function(){

        window.setTimeout(function myCallback(){
            l('1秒之后出现');
        },1000);
    }
 

    /* 
     * 研究案例2: 阻塞？不阻塞？
     */
    bee.caseQ2 = function(){

        var start = new Date;
        window.setTimeout(function(){
            var time = new Date - start;
            l('这个本来是300毫秒被执行的异步回调，实际上花了 '+time+ '毫秒，被阻塞了！')
        },300);
        var time2 = new Date - start;
        l('耗时：'+time2+',我是线程中同步代码，异步的代码并不会阻塞我！');
        while(new Date - start<500){}

        //这个例子很好的说明了，其实异步的代码中，既可能发生阻塞，也有可能不阻塞。
        //不阻塞的行为发生在异步函数的使用
        //阻塞发生在回调函数触发的时候
        //了解这个对“异步”的掌握很是关键。
    }


    /* 
     * 研究案例3: 阻塞之后，谁先触发
     */
    bee.caseQ3 = function(){

        var start = new Date;
        window.setTimeout(function(){
            var time = new Date - start;
            l('这个本来是400毫秒被执行的异步回调，实际上花了 '+time+ '毫秒，被阻塞了！')
        },400);
        window.setTimeout(function(){
            var time = new Date - start;
            l('这个本来是300毫秒被执行的异步回调，实际上花了 '+time+ '毫秒，被阻塞了！')
        },300);
        var time2 = new Date - start;
        l('耗时：'+time2+',我是线程中同步代码，异步的代码并不会阻塞我！');
        while(new Date - start<500){}

        //这个例子是上面的变体
        //但是能可以说明一个非常重要的道理。
        //这里对于两个异步函数 setTimeout 而言，都会被阻塞的。这个时候，对于延时300毫秒也好、400毫秒也好，都是过了原本该触发的时间。
        //那么到底哪个先触发呢？是代码靠前的先触发，还是别的？
        //答案是，看参数中的那个数值，谁小就先触发
    }


    /* 
     * 研究案例4: 神奇！既有同步属性，又有异步属性的DOM操作
     * DOM的操作，并不是异步的，而是即时生效的
     * 但是，它在浏览器界面上的渲染，确实被延时了，为什么？这个机制主要是为了“渲染状态一致的DOM”
     */
    bee.caseQ4 = function(){

        $(function(){
            var div  = document.createElement('div');
            var content = document.createTextNode('你好');
            div.append(content);
            document.body.append(div);
            div.style.background = 'red';

            var start = new Date;
            //添加下面的语句会阻塞UI的渲染(延迟2秒)
            //while(new Date - start<2000){}
        });
    }

    /* 
     * 研究案例5: 嵌套异步（延时函数）的触发顺序（1）
     * 这个比较简单
     */
    bee.caseQ5 = function(){
        window.setTimeout(function(){      //a
            l(1);
            window.setTimeout(function(){  //c
                l(3);
            },0);
        },0);
        window.setTimeout(function(){      //b
            l(2);
            window.setTimeout(function(){  //d
                l(4);
            },0);
        },0);
        //先后输出1、2、3、4
    }


    /* 
     * 研究案例6: 嵌套异步（延时函数）的触发顺序（2）
     */
    bee.caseQ6 = function(){
        window.setTimeout(function(){      //a
            l(1);
            window.setTimeout(function(){  //c
                l(3);
            },1000);
        },0);
        window.setTimeout(function(){      //b
            l(2);
            window.setTimeout(function(){  //d
                l(4);
            },0);
        },0);

        //和上例相比，c中的延时变成一秒，这个时候，执行的顺序如何呢？
        //其实就不好说了。
        //这个就靠考虑，代码本身执行的时间了。
        //如果本身运行很快（接近0），顺序是1、2、4、3
        //如果很耗时，也许，这个1毫秒的延时已经进入触发状态，比d先触发。是1、2、3、4
        //
        //如何c中的1毫秒改成1000毫秒，目前这种情况下，代码本身执行的时间，一定是不会超过1000的
        //所以结果必然是：1、2、4、3
    }


    /* 
     * 研究案例7: 嵌套异步（延时函数）的触发顺序（3）
     */
    bee.caseQ7 = function(){
        window.setTimeout(function(){      //a
            l(1);
            window.setTimeout(function(){  //c
                l(3);
            },1000);

            //用于阻塞的循环
            var s = new Date();
            while(new Date - s<1100){}
        },0);
        window.setTimeout(function(){      //b
            l(2);
            window.setTimeout(function(){  //d
                l(4);
            },0);
        },0);

        //和上例相比，增加了阻塞部分，时间是1100毫秒，这样子c的触发依然会比d早。
        //因为阻塞的作用“2”的输出也会被延后。
    }


    /* 
     * 研究案例8: 何时称一个函数为异步的呢？
     * 异步函数必然能通过以下测试
     */
    bee.caseQ8 = function(){
        //异步函数
        function fun (fn){
            window.setTimeout(function(){
                fn();
            },0);
        }
        //同步函数
        /*function fun (fn){
            fn();
        }*/

        //测试
        var a = 1;
        fun(function(){
            l(a==2);
        });
        a = 2;

        //能通过这个测试的就是异步函数，否则就是同步函数。
        //通常情况下我们的项目中没有这样子的测试案例让我们一目了然的知道，是不是异步函数。
        //所以我们只有看看fun函数的源代码了。
    }


    /* 
     * 研究案例9: 间或异步函数 
     * 最简单的展示
     */
    bee.caseQ9 = function(){

        function fun(a,fn){
            if(a==1){
                window.setTimeout(function(){
                    fn();
                },0)
            }else{
                fn();
            }
        }

        //异步
        fun(1,function(){l(111)});
        //同步
        fun(9,function(){l(222)});

        //间或异步函数，就是有的时候表现为异步函数，有的时候表现为同步函数。
        //取决于一些参数的变化啥的。
    }



    /* 
     * 研究案例10: 异步递归（反模式）
     */
    bee.caseQ10 = function(){

        var flag = 0,
            n    = 0;

        //模拟一个状态的改变
        window.setTimeout(function(){
            flag = 1;
        },3000);

        //异步递归函数
        function recursionFun(){
            if(flag!==1){
                l('递归循环发生'+(++n)+'次')
                window.setTimeout(function(){
                    recursionFun();
                },1000);
            }else{
                l('递归循环结束！')
            }
        } 
        recursionFun();

        //这里递归函数，在等待（使用延时函数）一个异步状态的改变。
        //延时函数的时间颗粒越小，得到改变信息更新的越精准。到时间设定为0的时候，状态的改变会马上得到通知。
        //但是缺点也是非常明显的！这样子消耗的内存资源太大了。所以这个是一种反模式。
    }





    return bee;
})(bee || {});



























