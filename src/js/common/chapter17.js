/*******************************
* 第十七章 异步
********************************/

var bee = (function(bee){


    /**************************************************************
    * 第1节  
    ***************************************************************/

    /* 
     * 研究案例1: 异步函数 【BOSS】
     *
     * 首先，一定要搞清楚4个的基础概念：
     * 1）异步函数，即能产生异步行为的函数本身。本案例中，setTimeout就是异步函数
     * 2）回调函数，作为参数传给“异步函数”的函数（或者赋值给“document.onready”的函数）。本例中，myCallback就是回调函数。
     * 3）事件处理器，已经在“事件队列”中的“回调函数”
     * 4）事件，促发“事件处理器”被调用的那个因素，比如：延时结束事件、dom加载完毕事件等等。
     *
     * 其次，要明白 js（异步）事件模型。说白了，就是js事件是如何工作的，工作原理如下：
     * 每当使用异步函数的时候，其回调函数就成为事件列队中一员，即事件处理器。当某的事件触发的时候，对应的事件处理器就会被调用。
     * 它具有如下特点：
     * 1）延时性：事件处理器一定是将来运行的，哪怕是0毫秒之后！
     * 2）对应性：使用异步函数，就有其对应的“事件处理器”加入列队。
     * 3）阻塞性：“事件处理器”只有在当前运行代码结束之后才能进行，否则，处于阻塞状态。
     *
     * 最后，解决一个困扰我多年的问题：
     * js中同时提及异步和阻塞，异步的怎么会被阻塞，而阻塞的又如何还能称得上异步，到底哪里出问题了？？
     * 解答，正确的答案是，异步的js，即阻塞又不阻塞。为何怎么说呢的？我们来看一个场景：
     * 我使用了一个异步函数setTimeout，这是个异步的行为，“不会阻塞”异步之后的其他代码的执行。这个时候，setTimeout的回调函数进入队列。
     * 等待“延时结束”事件的到来。假如，延时事件来的特别快（0毫秒之后就被触发），这个回调原本就会被马上执行，但是我们说了，js是一个单线程的，
     * 你要执行你这回调函数的时候，怎么着也得保证目前的线程上是空闲的，如果这个时候还有代码在跑的话，那么就会“被阻塞”。
     * 再举一个例子，node中的下面用法：
     * fs.readFile('/etc/passwd', (err, data) => {});
     * 这个是异步的，读取文件的事情其实交给别人去做了，所以，“不会阻塞”自己的代码。读取完毕文件之后，总会有执行回调的那个时候，这个时候，如果js
     * 自身线程中的代码都没有执行完毕，该回调就会被“阻塞”。
     * 由此可见，js中的“阻塞“仅仅发生在，回调被触发的时候!! 这样子的阻塞的发生的机会其实是很低的。因为大多数的时候，js线程还是处于空闲的状态呢~
     * node服务器就得益于这样子的“事件驱动”的优势。
     *
     * 其实在html中，是可以使用多线程的，只是这些线程还是辅助于js的主线程，为什么这么说呢，在html5中的其他线程其实是有很多的限制的，比如说
     * 他不能操作DOM，否则就很容易乱套的。
     * 
     */
    bee.caseQ1 = function(){

        window.setTimeout(function myCallback(){
            l('1秒之后出现');
        },1000);
    }
 

    /* 
     * 研究案例2: 阻塞？不阻塞？
     */
    bee.caseQ2 = function(){

        var start = new Date;
        window.setTimeout(function(){
            var time = new Date - start;
            l('这个本来是300毫秒被执行的异步回调，实际上花了 '+time+ '毫秒，被阻塞了！')
        },300);
        var time2 = new Date - start;
        l('耗时：'+time2+',我是线程中同步代码，异步的代码并不会阻塞我！');
        while(new Date - start<500){}

        //这个例子很好的说明了，其实异步的代码中，既可能发生阻塞，也有可能不阻塞。
        //不阻塞的行为发生在异步函数的使用
        //阻塞发生在回调函数触发的时候
        //了解这个对“异步”的掌握很是关键。
    }


    /* 
     * 研究案例3: 神奇！既有同步属性，又有异步属性的DOM操作
     * DOM的操作，并不是异步的，而是即时生效的
     * 但是，它在浏览器界面上的渲染，确实被延时了，为什么？这个机制主要是为了“渲染状态一致的DOM”
     */
    bee.caseQ3 = function(){

        $(function(){
            var div  = document.createElement('div');
            var content = document.createTextNode('你好');
            div.append(content);
            document.body.append(div);
            div.style.background = 'red';

            var start = new Date;
            //添加下面的语句会阻塞UI的渲染(延迟2秒)
            //while(new Date - start<2000){}
        });
    }







    return bee;
})(bee || {});









