/*******************************
* 第十七章 异步
********************************/

var bee = (function(bee){


    /**************************************************************
    * 第1节  
    ***************************************************************/

    /* 
     * 研究案例1: 异步函数 【BOSS】
     *
     * 首先，一定要搞清楚4个的基础概念：
     * 1）异步函数，即能产生异步行为的函数本身。本案例中，setTimeout就是异步函数
     * 2）回调函数，作为参数传给“异步函数”的函数（或者赋值给“document.onready”的函数）。本例中，myCallback就是回调函数。
     * 3）事件处理器，已经在“事件队列”中的“回调函数”
     * 4）事件，促发“事件处理器”被调用的那个因素，比如：延时结束事件、dom加载完毕事件等等。
     *
     * 其次，要明白 js（异步）事件模型。说白了，就是js事件是如何工作的，工作原理如下：
     * 每当使用异步函数的时候，其回调函数就成为事件列队中一员，即事件处理器。当某的事件触发的时候，对应的事件处理器就会被调用。
     * 它具有如下特点：
     * 1）延时性：事件处理器一定是将来运行的，哪怕是0毫秒之后！
     * 2）对应性：使用异步函数，就有其对应的“事件处理器”加入列队。
     * 3）阻塞性：“事件处理器”只有在当前运行代码结束之后才能进行，否则，处于阻塞状态。
     *
     * 最后，解决一个困扰我多年的问题：
     * js中同时提及异步和阻塞，异步的怎么会被阻塞，而阻塞的又如何还能称得上异步，到底哪里出问题了？？
     * 解答，正确的答案是，异步的js，即阻塞又不阻塞。为何怎么说呢的？我们来看一个场景：
     * 我使用了一个异步函数setTimeout，这是个异步的行为，“不会阻塞”异步之后的其他代码的执行。这个时候，setTimeout的回调函数进入队列。
     * 等待“延时结束”事件的到来。假如，延时事件来的特别快（0毫秒之后就被触发），这个回调原本就会被马上执行，但是我们说了，js是一个单线程的，
     * 你要执行你这回调函数的时候，怎么着也得保证目前的线程上是空闲的，如果这个时候还有代码在跑的话，那么就会“被阻塞”。
     * 再举一个例子，node中的下面用法：
     * fs.readFile('/etc/passwd', (err, data) => {});
     * 这个是异步的，读取文件的事情其实交给别人去做了，所以，“不会阻塞”自己的代码。读取完毕文件之后，总会有执行回调的那个时候，这个时候，如果js
     * 自身线程中的代码都没有执行完毕，该回调就会被“阻塞”。
     * 由此可见，js中的“阻塞“仅仅发生在，回调被触发的时候!! 这样子的阻塞的发生的机会其实是很低的。因为大多数的时候，js线程还是处于空闲的状态呢~
     * node服务器就得益于这样子的“事件驱动”的优势。
     */
    bee.caseQ1 = function(){

        window.setTimeout(function myCallback(){
            l('1秒之后出现');
        },1000);
    }
 

    /* 
     * 研究案例2: 阻塞
     */
    bee.caseQ2 = function(){

    }








    return bee;
})(bee || {});









